(* File automatically generated by Hacspec *)
From Hacspec Require Import Hacspec_Lib MachineIntegers.
From Coq Require Import ZArith.
Import List.ListNotations.
Open Scope Z_scope.
Open Scope bool_scope.
Open Scope hacspec_scope.

(** Should be moved to Hacspec_Lib.v **)
     Definition int_xI {WS : WORDSIZE} (a : int) : int := MachineIntegers.add (MachineIntegers.mul a (repr 2)) MachineIntegers.one.
Definition int_xO {WS : WORDSIZE} (a : int) : int := MachineIntegers.mul a (repr 2).
Number Notation int Pos.of_num_int Pos.to_num_int (via positive mapping [[int_xI] => xI, [int_xO] => xO , [MachineIntegers.one] => xH]) : hacspec_scope.
Notation "0" := (repr O).
Notation U8_t := int8.
Notation U8 := id.
Notation U16_t := int16.
Notation U16 := id.
Notation U32_t := int32.
Notation U32 := id.
Notation U64_t := int64.
Notation U64 := id.
Notation U128_t := int128.
Notation U128 := id.

Definition array_index {A: Type} `{Default A} {len : nat} (s: nseq A len) {WS} (i : @int WS) := array_index s (unsigned i).
Notation " x .[ a ]" := (array_index x a) (at level 40).
Definition array_upd {A: Type} {len : nat} (s: nseq A len) {WS} (i: @int WS) (new_v: A) : nseq A len := array_upd s (unsigned i) new_v.
Notation " x .[ i ]<- a" := (array_upd x i a) (at level 40).

Class Addition A := add : A -> A -> A.
Notation "a .+ b" := (add a b).
Instance array_add_inst {ws : WORDSIZE} {len: nat} : Addition (nseq (@int ws) len) := { add a b := a array_add b }.
Instance int_add_inst {ws : WORDSIZE} : Addition (@int ws) := { add a b := MachineIntegers.add a b }.

Class Subtraction A := sub : A -> A -> A.
Notation "a .- b" := (sub a b).
Instance array_sub_inst {ws : WORDSIZE} {len: nat} : Subtraction (nseq (@int ws) len) := { sub := array_join_map MachineIntegers.sub }.
Instance int_sub_inst {ws : WORDSIZE} : Subtraction (@int ws) := { sub a b := MachineIntegers.sub a b }.

Class Multiplication A := mul : A -> A -> A.
Notation "a .* b" := (mul a b).
Instance array_mul_inst {ws : WORDSIZE} {len: nat} : Multiplication (nseq (@int ws) len) := { mul a b := a array_mul b }.
Instance int_mul_inst {ws : WORDSIZE} : Multiplication (@int ws) := { mul a b := MachineIntegers.mul a b }.

Class Xor A := xor : A -> A -> A.
Notation "a .^ b" := (xor a b).

Instance array_xor_inst {ws : WORDSIZE} {len: nat} : Xor (nseq (@int ws) len) := { xor a b := a array_xor b }.
Instance int_xor_inst {ws : WORDSIZE} : Xor (@int ws) := { xor a b := MachineIntegers.xor a b }.

Definition new {A : Type} `{Default A} {len} : nseq A len := array_new_ default _.
Class array_or_seq A len :=
{ as_seq : seq A ; as_nseq : nseq A len }.

Arguments as_seq {_} {_} array_or_seq.
Arguments as_nseq {_} {_} array_or_seq.
Coercion as_seq : array_or_seq >-> seq.
Coercion as_nseq : array_or_seq >-> nseq.

Instance nseq_array_or_seq {A len} (a : nseq A len) : array_or_seq A len :=
{ as_seq := array_to_seq a ; as_nseq := a ; }.
Coercion nseq_array_or_seq : nseq >-> array_or_seq.

Instance seq_array_or_seq {A} `{Default A} (a : seq A) : array_or_seq A (length a) :=
{ as_seq := a ; as_nseq := array_from_seq _ a ; }.
Coercion seq_array_or_seq : seq >-> array_or_seq.

Definition update {A : Type}  `{Default A} {len slen} (s : nseq A len) {WS} (start : @int WS) (start_a : array_or_seq A slen) : nseq A len :=
array_update (a := A) (len := len) s (unsigned start) (as_seq start_a).

Definition to_le_U32s {A l} := array_to_le_uint32s (A := A) (l := l).
Axiom to_le_bytes : forall {ws : WORDSIZE} {len}, nseq (@int ws) len -> seq int8.
Definition from_seq {A : Type}  `{Default A} {len slen} (s : array_or_seq A slen) : nseq A len := array_from_seq _ (as_seq s).

Notation Seq_t := seq.
Notation len := (fun s => seq_len s : int32).

Definition array_slice {a: Type} `{Default a} {len : nat} (input: nseq a len) {WS} (start: @int WS) (slice_len: @int WS) : seq a := slice (array_to_seq input) (unsigned start) (unsigned (start .+ slice_len)).
Notation slice := array_slice.
Definition seq_new {A: Type} `{Default A} {WS} (len: @int WS) : seq A := seq_new (unsigned len).
Notation new_seq := seq_new.
Notation num_exact_chunks := seq_num_exact_chunks.
Notation get_exact_chunk := seq_get_exact_chunk.
Definition set_chunk {a: Type} `{Default a} {len} (s: seq a) {WS} (chunk_len: @int WS) (chunk_num: @int WS) (chunk: array_or_seq a len) : seq a := seq_set_chunk s (unsigned chunk_len) (unsigned chunk_num) (as_seq chunk).
Definition set_exact_chunk {a} `{H : Default a} {len} s {WS} := @set_chunk a H len s WS.
     Notation get_remainder_chunk := seq_get_remainder_chunk.
Notation "a <> b" := (negb (eqb a b)).

Notation from_secret_literal := nat_mod_from_secret_literal.
Definition pow2 {m} (x : @int WORDSIZE32) := nat_mod_pow2 m (unsigned x).
Instance nat_mod_addition {n} : Addition (nat_mod n) := { add a b := a +% b }.
Instance nat_mod_subtraction {n} : Subtraction (nat_mod n) := { sub a b := a -% b }.
Instance nat_mod_multiplication {n} : Multiplication (nat_mod n) := { mul a b := a *% b }.
Definition from_slice {a: Type} `{Default a} {len slen} (x : array_or_seq a slen) {WS} (start: @int WS) (slice_len: @int WS) := array_from_slice default len (as_seq x) (unsigned start) (unsigned slice_len).
Notation zero := nat_mod_zero.
Notation to_byte_seq_le := nat_mod_to_byte_seq_le.
Notation U128_to_le_bytes := u128_to_le_bytes.
Notation from_byte_seq_le := nat_mod_from_byte_seq_le.
Definition from_literal {m} := nat_mod_from_literal m.
Notation inv := nat_mod_inv.
Notation update_start := array_update_start.
Notation pow := nat_mod_pow_self.
Notation bit := nat_mod_bit.

Definition int_to_int {ws1 ws2} (i : @int ws1) : @int ws2 := repr (unsigned i).
Coercion int_to_int : int >-> int.
Notation push := seq_push.
Notation Build_secret := secret.
Notation "a -Ã— b" :=
(prod a b) (at level 80, right associativity) : hacspec_scope.
Notation Result_t := (fun '(x,y) => result).
Axiom TODO_name : Type.
Notation ONE := nat_mod_one.
Notation exp := nat_mod_exp.
Notation nat_mod := GZnZ.znz.
Instance nat_mod_znz_addition {n} : Addition (GZnZ.znz n) := { add a b := a +% b }.
Instance nat_mod_znz_subtraction {n} : Subtraction (GZnZ.znz n) := { sub a b := a -% b }.
Instance nat_mod_znz_multiplication {n} : Multiplication (GZnZ.znz n) := { mul a b := a *% b }.
Notation TWO := nat_mod_two.
Notation ne := (fun x y => negb (eqb x y)).
Notation eq := (eqb).
Notation rotate_right := (ror).
Notation to_be_U32s := array_to_be_uint32s.
Notation get_chunk := seq_get_chunk.
Notation num_chunks := seq_num_chunks.
Notation U64_to_be_bytes := uint64_to_be_bytes.
Notation to_be_bytes := array_to_be_bytes.
Notation U8_from_usize := uint8_from_usize.
Notation concat := seq_concat.
Notation declassify := id.
Notation U128_from_be_bytes := uint128_from_be_bytes.
Notation U128_to_be_bytes := uint128_to_be_bytes.
Notation slice_range := array_slice_range.
Notation truncate := seq_truncate.
Axiom array_to_be_uint64s : forall {A l}, nseq A l -> seq uint64.
Notation to_be_U64s := array_to_be_uint64s.
Notation classify := id.
Notation U64_from_U8 := uint64_from_uint8.
Fixpoint Build_Range_t (a b : nat) := match (b - a)%nat with O => [] | S n => match b with | O => [] | S b' => Build_Range_t a b' ++ [b] end end.
(** end of: Should be moved to Hacspec_Lib.v **)


(*Not implemented yet? todo(item)*)

(*Not implemented yet? todo(item)*)

(*Not implemented yet? todo(item)*)

Definition BLOCKSIZE : int32 :=
  (@repr WORDSIZE32 16).

Definition IVSIZE : int32 :=
  (@repr WORDSIZE32 12).

Definition KEY_LENGTH : int32 :=
  (@repr WORDSIZE32 4).

Definition ROUNDS : int32 :=
  (@repr WORDSIZE32 10).

Definition KEY_SCHEDULE_LENGTH : int32 :=
  (@repr WORDSIZE32 176).

Definition ITERATIONS : int32 :=
  (@repr WORDSIZE32 40).

Definition INVALID_KEY_EXPANSION_INDEX : int8 :=
  (@repr WORDSIZE8 1).

Notation Block_t := (nseq int8 BLOCKSIZE).
Definition Block : Block_t -> Block_t :=
  id.

Notation Word_t := (nseq int8 KEY_LENGTH).
Definition Word : Word_t -> Word_t :=
  id.

Notation RoundKey_t := (nseq int8 BLOCKSIZE).
Definition RoundKey : RoundKey_t -> RoundKey_t :=
  id.

Notation AesNonce_t := (nseq int8 IVSIZE).
Definition AesNonce : AesNonce_t -> AesNonce_t :=
  id.

Notation SBox_t := (nseq int8 256).
Definition SBox : SBox_t -> SBox_t :=
  id.

Notation RCon_t := (nseq int8 15).
Definition RCon : RCon_t -> RCon_t :=
  id.

Notation Bytes144_t := (nseq int8 144).
Definition Bytes144 : Bytes144_t -> Bytes144_t :=
  id.

Notation Bytes176_t := (nseq int8 KEY_SCHEDULE_LENGTH).
Definition Bytes176 : Bytes176_t -> Bytes176_t :=
  id.

Notation Key128_t := (nseq int8 BLOCKSIZE).
Definition Key128 : Key128_t -> Key128_t :=
  id.

Notation ByteSeqResult_t := (Result_t Seq_t U8_t int8).

Notation BlockResult_t := (Result_t Block_t int8).

Notation WordResult_t := (Result_t Word_t int8).

Definition SBOX : SBox_t :=
  SBox (array_from_list _ [0x63;0x7C;0x77;0x7B;0xF2;0x6B;0x6F;0xC5;0x30;0x01;0x67;0x2B;0xFE;0xD7;0xAB;0x76;0xCA;0x82;0xC9;0x7D;0xFA;0x59;0x47;0xF0;0xAD;0xD4;0xA2;0xAF;0x9C;0xA4;0x72;0xC0;0xB7;0xFD;0x93;0x26;0x36;0x3F;0xF7;0xCC;0x34;0xA5;0xE5;0xF1;0x71;0xD8;0x31;0x15;0x04;0xC7;0x23;0xC3;0x18;0x96;0x05;0x9A;0x07;0x12;0x80;0xE2;0xEB;0x27;0xB2;0x75;0x09;0x83;0x2C;0x1A;0x1B;0x6E;0x5A;0xA0;0x52;0x3B;0xD6;0xB3;0x29;0xE3;0x2F;0x84;0x53;0xD1;0x00;0xED;0x20;0xFC;0xB1;0x5B;0x6A;0xCB;0xBE;0x39;0x4A;0x4C;0x58;0xCF;0xD0;0xEF;0xAA;0xFB;0x43;0x4D;0x33;0x85;0x45;0xF9;0x02;0x7F;0x50;0x3C;0x9F;0xA8;0x51;0xA3;0x40;0x8F;0x92;0x9D;0x38;0xF5;0xBC;0xB6;0xDA;0x21;0x10;0xFF;0xF3;0xD2;0xCD;0x0C;0x13;0xEC;0x5F;0x97;0x44;0x17;0xC4;0xA7;0x7E;0x3D;0x64;0x5D;0x19;0x73;0x60;0x81;0x4F;0xDC;0x22;0x2A;0x90;0x88;0x46;0xEE;0xB8;0x14;0xDE;0x5E;0x0B;0xDB;0xE0;0x32;0x3A;0x0A;0x49;0x06;0x24;0x5C;0xC2;0xD3;0xAC;0x62;0x91;0x95;0xE4;0x79;0xE7;0xC8;0x37;0x6D;0x8D;0xD5;0x4E;0xA9;0x6C;0x56;0xF4;0xEA;0x65;0x7A;0xAE;0x08;0xBA;0x78;0x25;0x2E;0x1C;0xA6;0xB4;0xC6;0xE8;0xDD;0x74;0x1F;0x4B;0xBD;0x8B;0x8A;0x70;0x3E;0xB5;0x66;0x48;0x03;0xF6;0x0E;0x61;0x35;0x57;0xB9;0x86;0xC1;0x1D;0x9E;0xE1;0xF8;0x98;0x11;0x69;0xD9;0x8E;0x94;0x9B;0x1E;0x87;0xE9;0xCE;0x55;0x28;0xDF;0x8C;0xA1;0x89;0x0D;0xBF;0xE6;0x42;0x68;0x41;0x99;0x2D;0x0F;0xB0;0x54;0xBB;0x16]).

Definition RCON : RCon_t :=
  RCon (array_from_list _ [0x8d;0x01;0x02;0x04;0x08;0x10;0x20;0x40;0x80;0x1b;0x36;0x6c;0xd8;0xab;0x4d]).

Definition sub_bytes (state : Block_t) : Block_t :=
  let st := state : Block_t in
  foldi (@repr WORDSIZE32 0) BLOCKSIZE (fun i st =>
    st.[i]<-(SBOX.[(declassify (state.[i]))])) st.

Definition shift_row (i : int32) (shift : int32) (state : Block_t) : Block_t :=
  let out := state : Block_t in
  let out := out.[i]<-(state.[(i.+((@repr WORDSIZE32 4).*(shift.%(@repr WORDSIZE32 4))))]) : Block_t in
  let out := out.[(i.+(@repr WORDSIZE32 4))]<-(state.[(i.+((@repr WORDSIZE32 4).*((shift.+(@repr WORDSIZE32 1)).%(@repr WORDSIZE32 4))))]) : Block_t in
  let out := out.[(i.+(@repr WORDSIZE32 8))]<-(state.[(i.+((@repr WORDSIZE32 4).*((shift.+(@repr WORDSIZE32 2)).%(@repr WORDSIZE32 4))))]) : Block_t in
  out.[(i.+(@repr WORDSIZE32 12))]<-(state.[(i.+((@repr WORDSIZE32 4).*((shift.+(@repr WORDSIZE32 3)).%(@repr WORDSIZE32 4))))]).

Definition shift_rows (state : Block_t) : Block_t :=
  let state := shift_row (@repr WORDSIZE32 1) (@repr WORDSIZE32 1) state : Block_t in
  let state := shift_row (@repr WORDSIZE32 2) (@repr WORDSIZE32 2) state : Block_t in
  shift_row (@repr WORDSIZE32 3) (@repr WORDSIZE32 3) state.

Definition xtime (x : U8_t) : U8_t :=
  let x1 := shl x (@repr WORDSIZE32 1) : U8_t in
  let x7 := shr x (@repr WORDSIZE32 7) : U8_t in
  let x71 := x7.&(secret (@repr WORDSIZE8 1)) : U8_t in
  let x711b := x71.*(secret (@repr WORDSIZE8 27)) : U8_t in
  x1.^x711b.

Definition mix_column (c : int32) (state : Block_t) : Block_t :=
  let i0 := (@repr WORDSIZE32 4).*c : int32 in
  let s0 := state.[i0] : U8_t in
  let s1 := state.[(i0.+(@repr WORDSIZE32 1))] : U8_t in
  let s2 := state.[(i0.+(@repr WORDSIZE32 2))] : U8_t in
  let s3 := state.[(i0.+(@repr WORDSIZE32 3))] : U8_t in
  let st := state : Block_t in
  let tmp := ((s0.^s1).^s2).^s3 : U8_t in
  let st := st.[i0]<-((s0.^tmp).^(xtime (s0.^s1))) : Block_t in
  let st := st.[(i0.+(@repr WORDSIZE32 1))]<-((s1.^tmp).^(xtime (s1.^s2))) : Block_t in
  let st := st.[(i0.+(@repr WORDSIZE32 2))]<-((s2.^tmp).^(xtime (s2.^s3))) : Block_t in
  st.[(i0.+(@repr WORDSIZE32 3))]<-((s3.^tmp).^(xtime (s3.^s0))).

Definition mix_columns (state : Block_t) : Block_t :=
  let state := mix_column (@repr WORDSIZE32 0) state : Block_t in
  let state := mix_column (@repr WORDSIZE32 1) state : Block_t in
  let state := mix_column (@repr WORDSIZE32 2) state : Block_t in
  mix_column (@repr WORDSIZE32 3) state.

Definition add_round_key (state : Block_t) (key : RoundKey_t) : Block_t :=
  let out := state : Block_t in
  foldi (@repr WORDSIZE32 0) BLOCKSIZE (fun i out =>
    out.[i]<-((out.[i]).^(key.[i]))) out.

Definition aes_enc (state : Block_t) (round_key : RoundKey_t) : Block_t :=
  let state := sub_bytes state : Block_t in
  let state := shift_rows state : Block_t in
  let state := mix_columns state : Block_t in
  add_round_key state round_key.

Definition aes_enc_last (state : Block_t) (round_key : RoundKey_t) : Block_t :=
  let state := sub_bytes state : Block_t in
  let state := shift_rows state : Block_t in
  add_round_key state round_key.

Definition rounds_aes (state : Block_t) (key : Seq_t U8_t) : Block_t :=
  let out := state : Block_t in
  foldi (@repr WORDSIZE32 0) (num_chunks key BLOCKSIZE) (fun i out =>
    let '(_,key_block) := get_chunk key BLOCKSIZE i : (int32 'Ã— Seq_t U8_t) in
    aes_enc out (from_seq key_block)) out.

Definition block_cipher_aes (input : Block_t) (key : Seq_t U8_t) (nr : int32) : Block_t :=
  let k0 := from_slice_range key (Build_Range_t (@repr WORDSIZE32 0)(@repr WORDSIZE32 16)) : RoundKey_t in
  let k := from_slice_range key (Build_Range_t (@repr WORDSIZE32 16)(nr.*(@repr WORDSIZE32 16))) : Seq_t U8_t in
  let kn := from_slice key (nr.*(@repr WORDSIZE32 16)) (@repr WORDSIZE32 16) : RoundKey_t in
  let state := add_round_key input k0 : Block_t in
  let state := rounds_aes state k : Block_t in
  aes_enc_last state kn.

Definition rotate_word (w : Word_t) : Word_t :=
  Word (array_from_list _ [w.[(@repr WORDSIZE32 1)];w.[(@repr WORDSIZE32 2)];w.[(@repr WORDSIZE32 3)];w.[(@repr WORDSIZE32 0)]]).

Definition slice_word (w : Word_t) : Word_t :=
  Word (array_from_list _ [SBOX.[(declassify_usize_from_U8 (w.[(@repr WORDSIZE32 0)]))];SBOX.[(declassify_usize_from_U8 (w.[(@repr WORDSIZE32 1)]))];SBOX.[(declassify_usize_from_U8 (w.[(@repr WORDSIZE32 2)]))];SBOX.[(declassify_usize_from_U8 (w.[(@repr WORDSIZE32 3)]))]]).

Definition aes_keygen_assist (w : Word_t) (rcon : U8_t) : Word_t :=
  let k := rotate_word w : Word_t in
  let k := slice_word k : Word_t in
  k.[(@repr WORDSIZE32 0)]<-((k.[(@repr WORDSIZE32 0)]).^rcon).

Definition key_expansion_word (w0 : Word_t) (w1 : Word_t) (i : int32) (nk : int32) (nr : int32) : Result_t Word_t int8 :=
  let k := w1 : Word_t in
  let result := Err INVALID_KEY_EXPANSION_INDEX : Result_t Word_t int8 in
  let '(k,result) := if
      i<.?((@repr WORDSIZE32 4).*(nr.+(@repr WORDSIZE32 1)))
    then
      let k := if
          (i.%nk)=.?(@repr WORDSIZE32 0)
        then
          let '(k,result) := let k := aes_keygen_assist k (RCON.[(i./nk)]) : Word_t in
            (k,result) : (_ 'Ã— Result_t Word_t int8) in
          k
        else
          if
            andb (nk>.?(@repr WORDSIZE32 6)) ((i.%nk)=.?(@repr WORDSIZE32 4))
          then
            let '(k,result) := let k := slice_word k : Word_t in
              (k,result) : (_ 'Ã— Result_t Word_t int8) in
            k
          else
            k : Word_t in
      let k := foldi (@repr WORDSIZE32 0) (@repr WORDSIZE32 4) (fun i k =>
          k.[i]<-((k.[i]).^(w0.[i]))) k : Word_t in
      let result := Ok k : Result_t Word_t int8 in
      (k,result)
    else
      (k,result) : (_ 'Ã— Result_t Word_t int8) in
  result.

Definition key_expansion_aes (key : Seq_t U8_t) (nk : int32) (nr : int32) (key_schedule_length : int32) (key_length : int32) (iterations : int32) : Result_t Seq_t U8_t int8 :=
  let key_ex := new_seq key_schedule_length : Seq_t U8_t in
  let key_ex := update_start key_ex key : Seq_t U8_t in
  let word_size := key_length : int32 in
  let key_ex := foldi (@repr WORDSIZE32 0) iterations (fun j key_ex =>
      let i := j.+word_size : int32 in
      let word := match branch (key_expansion_word (from_slice key_ex ((@repr WORDSIZE32 4).*(i.-word_size)) (@repr WORDSIZE32 4)) (from_slice key_ex (((@repr WORDSIZE32 4).*i).-(@repr WORDSIZE32 4)) (@repr WORDSIZE32 4)) i nk nr) with
        | {|
          0 := residual;
        |} => from_residual residual
        | {|
          0 := val;
        |} => val
        end : Word_t in
      update key_ex ((@repr WORDSIZE32 4).*i) word) key_ex : Seq_t U8_t in
  Ok key_ex.

Definition aes_encrypt_block (k : Seq_t U8_t) (input : Block_t) (nk : int32) (nr : int32) (key_schedule_length : int32) (key_length : int32) (iterations : int32) : Result_t Block_t int8 :=
  let key_ex := match branch (key_expansion_aes k nk nr key_schedule_length key_length iterations) with
    | {|
      0 := residual;
    |} => from_residual residual
    | {|
      0 := val;
    |} => val
    end : Seq_t U8_t in
  Ok (block_cipher_aes input key_ex nr).

Definition aes128_encrypt_block (k : Key128_t) (input : Block_t) : Block_t :=
  unwrap (aes_encrypt_block (from_seq k) input KEY_LENGTH ROUNDS KEY_SCHEDULE_LENGTH KEY_LENGTH ITERATIONS).

Definition aes_ctr_key_block (k : Seq_t U8_t) (n : AesNonce_t) (c : U32_t) (nk : int32) (nr : int32) (key_schedule_length : int32) (key_length : int32) (iterations : int32) : Result_t Block_t int8 :=
  let input := new : Block_t in
  let input := update input (@repr WORDSIZE32 0) n : Block_t in
  let input := update input (@repr WORDSIZE32 12) (U32_to_be_bytes c) : Block_t in
  aes_encrypt_block k input nk nr key_schedule_length key_length iterations.

Definition xor_block (block : Block_t) (key_block : Block_t) : Block_t :=
  let out := block : Block_t in
  foldi (@repr WORDSIZE32 0) BLOCKSIZE (fun i out =>
    out.[i]<-((out.[i]).^(key_block.[i]))) out.

Definition aes_counter_mode (key : Seq_t U8_t) (nonce : AesNonce_t) (counter : U32_t) (msg : Seq_t U8_t) (nk : int32) (nr : int32) (key_schedule_length : int32) (key_length : int32) (iterations : int32) : Result_t Seq_t U8_t int8 :=
  let ctr := counter : U32_t in
  let blocks_out := new_seq (len msg) : Seq_t U8_t in
  let n_blocks := num_exact_chunks msg BLOCKSIZE : int32 in
  let '(blocks_out,ctr) := foldi (@repr WORDSIZE32 0) n_blocks (fun i '(blocks_out,ctr) =>
      let msg_block := get_exact_chunk msg BLOCKSIZE i : Seq_t U8_t in
      let key_block := match branch (aes_ctr_key_block key nonce ctr nk nr key_schedule_length key_length iterations) with
        | {|
          0 := residual;
        |} => from_residual residual
        | {|
          0 := val;
        |} => val
        end : Block_t in
      let blocks_out := set_chunk blocks_out BLOCKSIZE i (xor_block (from_seq msg_block) key_block) : Seq_t U8_t in
      let ctr := ctr.+(secret (@repr WORDSIZE32 1)) : U32_t in
      (blocks_out,ctr)) (blocks_out,ctr) : (Seq_t U8_t 'Ã— U32_t) in
  let last_block := get_remainder_chunk msg BLOCKSIZE : Seq_t U8_t in
  let last_block_len := len last_block : int32 in
  let blocks_out := if
      last_block_len<>(@repr WORDSIZE32 0)
    then
      let last_block := update_start new last_block : Block_t in
      let key_block := match branch (aes_ctr_key_block key nonce ctr nk nr key_schedule_length key_length iterations) with
        | {|
          0 := residual;
        |} => from_residual residual
        | {|
          0 := val;
        |} => val
        end : Block_t in
      set_chunk blocks_out BLOCKSIZE n_blocks (slice_range (xor_block last_block key_block) (Build_Range_t (@repr WORDSIZE32 0)last_block_len))
    else
      blocks_out : Seq_t U8_t in
  Ok blocks_out.

Definition aes128_encrypt (key : Key128_t) (nonce : AesNonce_t) (counter : U32_t) (msg : Seq_t U8_t) : Seq_t U8_t :=
  unwrap (aes_counter_mode (from_seq key) nonce counter msg KEY_LENGTH ROUNDS KEY_SCHEDULE_LENGTH KEY_LENGTH ITERATIONS).

Definition aes128_decrypt (key : Key128_t) (nonce : AesNonce_t) (counter : U32_t) (ctxt : Seq_t U8_t) : Seq_t U8_t :=
  unwrap (aes_counter_mode (from_seq key) nonce counter ctxt KEY_LENGTH ROUNDS KEY_SCHEDULE_LENGTH KEY_LENGTH ITERATIONS).
